"use strict";(globalThis.webpackChunksentient_machines_handbook=globalThis.webpackChunksentient_machines_handbook||[]).push([[319],{4020:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"ros2/services-actions","title":"ROS 2 Services and Actions: Client/Server Patterns","description":"While Topics are excellent for continuous, asynchronous data streams, robotics often requires direct, request-response communication. ROS 2 provides two main client/server patterns for this: Services for simple, synchronous calls, and Actions for long-running, goal-oriented tasks.","source":"@site/docs/02-ros2/03-services-actions.md","sourceDirName":"02-ros2","slug":"/ros2/services-actions","permalink":"/BOOK-WITH-RAGCHATBOT/docs/ros2/services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/CodeVoyager007/BOOK-WITH-RAGCHATBOT/tree/main/book/docs/02-ros2/03-services-actions.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"ROS 2 Services and Actions: Client/Server Patterns","sidebar_label":"Services & Actions"},"sidebar":"tutorialSidebar","previous":{"title":"Communication","permalink":"/BOOK-WITH-RAGCHATBOT/docs/ros2/communication"},"next":{"title":"Python Agents","permalink":"/BOOK-WITH-RAGCHATBOT/docs/ros2/python-agents"}}');var r=i(4848),t=i(8453);const o={title:"ROS 2 Services and Actions: Client/Server Patterns",sidebar_label:"Services & Actions"},c="ROS 2 Services and Actions: Client/Server Patterns",a={},l=[{value:"Services: Synchronous Request/Response",id:"services-synchronous-requestresponse",level:2},{value:"Service Definition",id:"service-definition",level:3},{value:"Creating a Service Server (Python)",id:"creating-a-service-server-python",level:3},{value:"Creating a Service Client (Python)",id:"creating-a-service-client-python",level:3},{value:"Actions: Goal-Oriented Feedback and Preemption",id:"actions-goal-oriented-feedback-and-preemption",level:2},{value:"Action Definition",id:"action-definition",level:3},{value:"Action Client/Server Interaction",id:"action-clientserver-interaction",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ros-2-services-and-actions-clientserver-patterns",children:"ROS 2 Services and Actions: Client/Server Patterns"})}),"\n",(0,r.jsxs)(n.p,{children:["While Topics are excellent for continuous, asynchronous data streams, robotics often requires direct, request-response communication. ROS 2 provides two main client/server patterns for this: ",(0,r.jsx)(n.strong,{children:"Services"})," for simple, synchronous calls, and ",(0,r.jsx)(n.strong,{children:"Actions"})," for long-running, goal-oriented tasks."]}),"\n",(0,r.jsx)(n.h2,{id:"services-synchronous-requestresponse",children:"Services: Synchronous Request/Response"}),"\n",(0,r.jsxs)(n.p,{children:["A ROS 2 Service is a simple remote procedure call (RPC) mechanism. A ",(0,r.jsx)(n.strong,{children:"client"})," sends a request to a ",(0,r.jsx)(n.strong,{children:"server"}),", and the server processes it and sends back a single response. This interaction is synchronous and blocking from the client's perspective: the client waits for the response before proceeding."]}),"\n",(0,r.jsx)(n.p,{children:"Services are ideal for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'Triggering an event (e.g., "take a picture").'}),"\n",(0,r.jsx)(n.li,{children:'Querying information (e.g., "get robot\'s current pose").'}),"\n",(0,r.jsx)(n.li,{children:'Changing a configuration (e.g., "set motor speed to X").'}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"service-definition",children:"Service Definition"}),"\n",(0,r.jsxs)(n.p,{children:["Services are defined in ",(0,r.jsx)(n.code,{children:".srv"})," files. A service definition consists of a request part and a response part, separated by ",(0,r.jsx)(n.code,{children:"---"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Example: ",(0,r.jsx)(n.code,{children:"example_interfaces/srv/AddTwoInts.srv"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"int64 a\nint64 b\n---\nint64 sum\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-service-server-python",children:"Creating a Service Server (Python)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts # Import the service type\n\nclass MinimalService(Node):\n\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Service server ready.')\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')\n        self.get_logger().info(f'Sending response: sum={response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    minimal_service.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-service-client-python",children:"Creating a Service Client (Python)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import sys\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass MinimalClientAsync(Node):\n\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClientAsync()\n    response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))\n    minimal_client.get_logger().info(f'Result of add_two_ints: for {sys.argv[1]} + {sys.argv[2]} = {response.sum}')\n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,r.jsx)(n.h2,{id:"actions-goal-oriented-feedback-and-preemption",children:"Actions: Goal-Oriented Feedback and Preemption"}),"\n",(0,r.jsx)(n.p,{children:"Actions are built on top of Services and Topics, designed for tasks that take a long time to execute, can be preempted (cancelled), and provide continuous feedback. Think of navigating a robot to a target location: it's a long-running process, you want to know its progress, and you might want to stop it midway."}),"\n",(0,r.jsx)(n.p,{children:"An Action consists of:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Goal"}),": The request to perform the task."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": The final outcome of the task."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Feedback"}),": Intermediate updates on the progress of the task."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"action-definition",children:"Action Definition"}),"\n",(0,r.jsxs)(n.p,{children:["Actions are defined in ",(0,r.jsx)(n.code,{children:".action"})," files, which combine a goal, result, and feedback message definition, each separated by ",(0,r.jsx)(n.code,{children:"---"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Example: ",(0,r.jsx)(n.code,{children:"example_interfaces/action/Fibonacci.action"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"int32 order\n---\nint32[] sequence\n---\nint32[] partial_sequence\n"})}),"\n",(0,r.jsx)(n.h3,{id:"action-clientserver-interaction",children:"Action Client/Server Interaction"}),"\n",(0,r.jsx)(n.p,{children:"The interaction with an Action server is more complex than with a Service, involving asynchronous communication for goals, results, and feedback."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Client"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Sends a Goal."}),"\n",(0,r.jsx)(n.li,{children:"Receives continuous Feedback."}),"\n",(0,r.jsx)(n.li,{children:"Receives a final Result (or cancellation notification)."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Server"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Receives a Goal."}),"\n",(0,r.jsx)(n.li,{children:"Continuously sends Feedback."}),"\n",(0,r.jsx)(n.li,{children:"Sends a final Result (or handles preemption)."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Actions are crucial for complex, multi-step robotic behaviors where monitoring progress and dynamic intervention are necessary."}),"\n",(0,r.jsx)(n.p,{children:"Understanding when to use Topics, Services, and Actions is fundamental to designing robust and efficient ROS 2 applications. Each communication pattern serves a distinct purpose, and choosing the right one for the job is key to building sophisticated robotic systems."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>c});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);