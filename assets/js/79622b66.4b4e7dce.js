"use strict";(globalThis.webpackChunksentient_machines_handbook=globalThis.webpackChunksentient_machines_handbook||[]).push([[131],{2933:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"sim/urdf-basics","title":"URDF Basics: Unified Robot Description Format","description":"Before we can simulate a robot or even interact with a physical one, we need a way to describe it digitally. The Unified Robot Description Format (URDF) is an XML-based file format used in ROS 2 to describe all the physical and kinematic properties of a robot. It\'s the robot\'s DNA, telling simulation environments and control software everything they need to know.","source":"@site/docs/03-sim/01-urdf-basics.md","sourceDirName":"03-sim","slug":"/sim/urdf-basics","permalink":"/BOOK-WITH-RAGCHATBOT/docs/sim/urdf-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/CodeVoyager007/BOOK-WITH-RAGCHATBOT/tree/main/book/docs/03-sim/01-urdf-basics.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"URDF Basics: Unified Robot Description Format","sidebar_label":"URDF Basics"},"sidebar":"tutorialSidebar","previous":{"title":"Digital Twins (Simulation)","permalink":"/BOOK-WITH-RAGCHATBOT/docs/category/simulation"},"next":{"title":"Modeling Bipeds","permalink":"/BOOK-WITH-RAGCHATBOT/docs/sim/modeling-bipeds"}}');var o=n(4848),s=n(8453);const t={title:"URDF Basics: Unified Robot Description Format",sidebar_label:"URDF Basics"},l="URDF Basics: Unified Robot Description Format",a={},c=[{value:"What does URDF describe?",id:"what-does-urdf-describe",level:2},{value:"Structure of a URDF File",id:"structure-of-a-urdf-file",level:2},{value:"Links (<code>&lt;link&gt;</code>)",id:"links-link",level:2},{value:"Joints (<code>&lt;joint&gt;</code>)",id:"joints-joint",level:2},{value:"Xacro: Simplifying URDF",id:"xacro-simplifying-urdf",level:2}];function d(e){const i={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"urdf-basics-unified-robot-description-format",children:"URDF Basics: Unified Robot Description Format"})}),"\n",(0,o.jsxs)(i.p,{children:["Before we can simulate a robot or even interact with a physical one, we need a way to describe it digitally. The ",(0,o.jsx)(i.strong,{children:"Unified Robot Description Format (URDF)"})," is an XML-based file format used in ROS 2 to describe all the physical and kinematic properties of a robot. It's the robot's DNA, telling simulation environments and control software everything they need to know."]}),"\n",(0,o.jsx)(i.h2,{id:"what-does-urdf-describe",children:"What does URDF describe?"}),"\n",(0,o.jsx)(i.p,{children:"A URDF file typically contains descriptions of:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Links"}),": The rigid bodies of the robot (e.g., base, arm segments, wheels). Each link has physical properties like mass, inertia, and visual/collision geometries."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:"Joints"}),": The connections between links, allowing them to move relative to each other. Joints have properties like type (revolute, prismatic, fixed), axis of rotation, limits, and dynamics."]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"structure-of-a-urdf-file",children:"Structure of a URDF File"}),"\n",(0,o.jsxs)(i.p,{children:["A URDF file starts with a ",(0,o.jsx)(i.code,{children:"<robot>"})," tag, and inside it, you define all your links and joints."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_robot">\n\n  \x3c!-- =============================== --\x3e\n  \x3c!--        LINK DEFINITIONS         --\x3e\n  \x3c!-- =============================== --\x3e\n\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.2 0.1 0.05"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0 0 0.8 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.2 0.1 0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.0"/>\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.01" iyz="0.0" izz="0.01"/>\n    </inertial>\n  </link>\n\n  <link name="left_wheel">\n    <visual>\n      <geometry>\n        <cylinder length="0.02" radius="0.03"/>\n      </geometry>\n      <material name="black">\n        <color rgba="0 0 0 1"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.02" radius="0.03"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.1"/>\n      <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- More links for right_wheel, etc. --\x3e\n\n  \x3c!-- =============================== --\x3e\n  \x3c!--       JOINT DEFINITIONS         --\x3e\n  \x3c!-- =============================== --\x3e\n\n  <joint name="base_to_left_wheel" type="continuous">\n    <parent link="base_link"/>\n    <child link="left_wheel"/>\n    <origin xyz="0.0 -0.06 0.0" rpy="1.57079632679 0 0"/> \x3c!-- Rotate so wheel is upright --\x3e\n    <axis xyz="0 0 1"/> \x3c!-- Axis of rotation --\x3e\n  </joint>\n\n  \x3c!-- More joints for base_to_right_wheel, etc. --\x3e\n\n  \x3c!-- =============================== --\x3e\n  \x3c!--       GAZEBO PROPERTIES         --\x3e\n  \x3c!-- =============================== --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Blue</material>\n  </gazebo>\n  <gazebo reference="left_wheel">\n    <material>Gazebo/Black</material>\n  </gazebo>\n\n  \x3c!-- You might add transmission and controller definitions here too for real robots --\x3e\n\n</robot>\n'})}),"\n",(0,o.jsxs)(i.h2,{id:"links-link",children:["Links (",(0,o.jsx)(i.code,{children:"<link>"}),")"]}),"\n",(0,o.jsxs)(i.p,{children:["Each ",(0,o.jsx)(i.code,{children:"<link>"})," tag defines a rigid body."]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"name"})}),": A unique identifier for the link."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"visual"})}),": Defines how the link looks.","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"geometry"}),": Shape (box, cylinder, sphere) or mesh (",(0,o.jsx)(i.code,{children:".dae"}),", ",(0,o.jsx)(i.code,{children:".stl"}),")."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"material"}),": Color or texture."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"collision"})}),": Defines the shape used for collision detection. Often simpler than the visual geometry for performance."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"inertial"})}),": Physical properties crucial for physics simulation.","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"mass"}),": Mass of the link."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"inertia"}),": 3x3 rotational inertia matrix. This is critical for realistic dynamics."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.h2,{id:"joints-joint",children:["Joints (",(0,o.jsx)(i.code,{children:"<joint>"}),")"]}),"\n",(0,o.jsxs)(i.p,{children:["Each ",(0,o.jsx)(i.code,{children:"<joint>"})," tag defines how two links are connected."]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"name"})}),": Unique identifier for the joint."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"type"})}),":","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"revolute"}),": Rotational joint with a limited range."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"continuous"}),": Rotational joint with unlimited range (e.g., wheel)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"prismatic"}),": Linear joint with a limited range."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"fixed"}),": No movement, effectively combines two links into one rigid body."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsxs)(i.strong,{children:[(0,o.jsx)(i.code,{children:"parent"})," / ",(0,o.jsx)(i.code,{children:"child"})]}),": Specifies the two links connected by the joint."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"origin"})}),": Defines the joint's position and orientation relative to the parent link.","\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"xyz"}),": Position (x, y, z)."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"rpy"}),": Roll, Pitch, Yaw rotation (in radians)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"axis"})}),": Defines the axis of rotation or translation for revolute, continuous, and prismatic joints."]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.strong,{children:(0,o.jsx)(i.code,{children:"limit"})}),": For ",(0,o.jsx)(i.code,{children:"revolute"})," and ",(0,o.jsx)(i.code,{children:"prismatic"})," joints, defines the upper and lower limits, velocity limits, and effort limits."]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"xacro-simplifying-urdf",children:"Xacro: Simplifying URDF"}),"\n",(0,o.jsxs)(i.p,{children:["Writing complex robots in pure URDF can be very repetitive and hard to manage. ",(0,o.jsx)(i.strong,{children:"Xacro (XML Macros)"})," is an XML macro language that allows you to use variables, mathematical expressions, and macros to generate URDF files. This dramatically reduces duplication and improves readability."]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="my_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\n\n  \x3c!-- Define properties as xacro properties --\x3e\n  <xacro:property name="M_PI" value="3.1415926535897931" />\n  <xacro:property name="wheel_radius" value="0.03" />\n  <xacro:property name="wheel_width" value="0.02" />\n\n  \x3c!-- Define a macro for a wheel --\x3e\n  <xacro:macro name="wheel" params="prefix parent_link x_coord y_coord">\n    <link name="${prefix}_wheel">\n      <visual>\n        <geometry>\n          <cylinder length="${wheel_width}" radius="${wheel_radius}"/>\n        </geometry>\n      </visual>\n      <inertial>\n        <mass value="0.1"/>\n        <inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/>\n      </inertial>\n    </link>\n\n    <joint name="${parent_link}_to_${prefix}_wheel" type="continuous">\n      <parent link="${parent_link}"/>\n      <child link="${prefix}_wheel"/>\n      <origin xyz="${x_coord} ${y_coord} 0.0" rpy="${M_PI/2} 0 0"/>\n      <axis xyz="0 0 1"/>\n    </joint>\n  </xacro:macro>\n\n  \x3c!-- Base Link definition (same as before) --\x3e\n  <link name="base_link">...</link>\n\n  \x3c!-- Use the wheel macro --\x3e\n  <xacro:wheel prefix="left" parent_link="base_link" x_coord="0.0" y_coord="-0.06" />\n  <xacro:wheel prefix="right" parent_link="base_link" x_coord="0.0" y_coord="0.06" />\n\n</robot>\n'})}),"\n",(0,o.jsx)(i.p,{children:"To process an Xacro file into a standard URDF:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-bash",children:"ros2 run xacro xacro my_robot.urdf.xacro > my_robot.urdf\n"})}),"\n",(0,o.jsx)(i.p,{children:"URDF is your robot's blueprint. A well-defined URDF is critical for accurate simulation, effective control, and proper visualization in tools like RViz. Mastering it is the first step in bringing your robot designs to life."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>l});var r=n(6540);const o={},s=r.createContext(o);function t(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);