"use strict";(globalThis.webpackChunksentient_machines_handbook=globalThis.webpackChunksentient_machines_handbook||[]).push([[803],{4451:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"capstone/sim-to-real","title":"Sim-to-Real: The Reality Gap and Domain Randomization","description":"One of the most persistent and challenging problems in robotics is the \\"Sim-to-Real\\" gap. Algorithms and policies developed and trained in simulation often perform poorly or fail entirely when transferred to physical robots. This disparity arises because simulations, no matter how sophisticated, are imperfect models of reality. This chapter explores the nature of the reality gap and introduces Domain Randomization as a powerful technique to bridge it.","source":"@site/docs/06-capstone/02-sim-to-real.md","sourceDirName":"06-capstone","slug":"/capstone/sim-to-real","permalink":"/BOOK-WITH-RAGCHATBOT/docs/capstone/sim-to-real","draft":false,"unlisted":false,"editUrl":"https://github.com/CodeVoyager007/BOOK-WITH-RAGCHATBOT/tree/main/book/docs/06-capstone/02-sim-to-real.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Sim-to-Real: The Reality Gap and Domain Randomization","sidebar_label":"Sim-to-Real"},"sidebar":"tutorialSidebar","previous":{"title":"Capstone Project Design","permalink":"/BOOK-WITH-RAGCHATBOT/docs/capstone/project-design"},"next":{"title":"Safety & Ethics","permalink":"/BOOK-WITH-RAGCHATBOT/docs/capstone/safety-ethics"}}');var o=i(4848),a=i(8453);const s={title:"Sim-to-Real: The Reality Gap and Domain Randomization",sidebar_label:"Sim-to-Real"},r="Sim-to-Real: The Reality Gap and Domain Randomization",l={},d=[{value:"The Reality Gap: Where Simulations Fall Short",id:"the-reality-gap-where-simulations-fall-short",level:2},{value:"Bridging the Gap with Domain Randomization",id:"bridging-the-gap-with-domain-randomization",level:2},{value:"What to Randomize?",id:"what-to-randomize",level:3},{value:"How Domain Randomization Works",id:"how-domain-randomization-works",level:2},{value:"Example: Randomizing Object Position and Texture in Isaac Sim (Conceptual)",id:"example-randomizing-object-position-and-texture-in-isaac-sim-conceptual",level:3},{value:"When to use Domain Randomization?",id:"when-to-use-domain-randomization",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"sim-to-real-the-reality-gap-and-domain-randomization",children:"Sim-to-Real: The Reality Gap and Domain Randomization"})}),"\n",(0,o.jsxs)(n.p,{children:["One of the most persistent and challenging problems in robotics is the ",(0,o.jsx)(n.strong,{children:'"Sim-to-Real" gap'}),". Algorithms and policies developed and trained in simulation often perform poorly or fail entirely when transferred to physical robots. This disparity arises because simulations, no matter how sophisticated, are imperfect models of reality. This chapter explores the nature of the reality gap and introduces ",(0,o.jsx)(n.strong,{children:"Domain Randomization"})," as a powerful technique to bridge it."]}),"\n",(0,o.jsx)(n.h2,{id:"the-reality-gap-where-simulations-fall-short",children:"The Reality Gap: Where Simulations Fall Short"}),"\n",(0,o.jsx)(n.p,{children:"The reality gap stems from mismatches between the simulated environment and the real world. These discrepancies can be subtle or significant and include:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor Noise and Imperfections"}),": Simulated sensors are often idealized. Real-world sensors have noise, drift, calibration errors, and occlusions that are hard to perfectly model."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Actuator Imperfections"}),": Simulated motors often respond perfectly. Real-world actuators have latency, backlash, friction, and torque limits that are complex to simulate accurately."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Physics Mismatches"}),": Friction coefficients, object masses, contact dynamics, and material properties are never perfectly known or simulated. Even tiny errors accumulate, leading to divergent behaviors."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Environmental Variation"}),": The real world is infinitely complex. Subtle variations in lighting, texture, object placement, and unseen objects can drastically affect perception and control."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Modeling Errors"}),": Any simplification in the robot's physical model (e.g., in URDF for inertia or collision meshes) can lead to mismatches."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Even a perfectly designed robot with a perfectly written controller can fail if the simulation it was tested in doesn't adequately capture the complexities of the real world."}),"\n",(0,o.jsx)(n.h2,{id:"bridging-the-gap-with-domain-randomization",children:"Bridging the Gap with Domain Randomization"}),"\n",(0,o.jsxs)(n.p,{children:["Instead of trying to make the simulation perfectly match reality (which is often impossible), ",(0,o.jsx)(n.strong,{children:"Domain Randomization (DR)"})," takes a different approach. The idea is to randomize a wide range of parameters in the simulation during training, such that the real world appears as just another variation within the simulated data."]}),"\n",(0,o.jsx)(n.p,{children:"The goal is to expose the agent to such diverse simulated environments that it learns a robust policy that generalizes well to unseen variations, including those found in the real world."}),"\n",(0,o.jsx)(n.h3,{id:"what-to-randomize",children:"What to Randomize?"}),"\n",(0,o.jsx)(n.p,{children:"Almost anything in the simulation can be randomized:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visual Properties"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Textures"}),": Randomly change textures of objects and the environment."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Colors"}),": Randomly change the colors of objects."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Lighting"}),": Randomly vary light sources (position, intensity, color), ambient light, and shadows."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Camera Properties"}),": Randomize intrinsic (FOV, distortion) and extrinsic (position, orientation) camera parameters."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Backgrounds"}),": Randomly swap backgrounds or use real-world images as backgrounds."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Physics Properties"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Friction"}),": Vary friction coefficients (e.g., ",(0,o.jsx)(n.code,{children:"mu1"}),", ",(0,o.jsx)(n.code,{children:"mu2"}),") for surfaces."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Mass and Inertia"}),": Randomly perturb the mass and inertia of objects."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Joint Properties"}),": Randomize joint limits, stiffness, and damping."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Gravity"}),": Even gravity can be slightly randomized (though less common for Earth-bound robots)."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Object Properties"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Position and Orientation"}),": Randomly place objects within a specified range."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Number of Objects"}),": Vary the quantity of objects in the scene."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Object Models"}),": Introduce variations in object models, or even entirely new object models."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor Properties"}),":","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor Noise"}),": Add various types of noise (Gaussian, salt-and-pepper) to simulated sensor readings."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor Lags/Delays"}),": Simulate realistic sensor latencies."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"how-domain-randomization-works",children:"How Domain Randomization Works"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Identify Randomizable Parameters"}),": Determine which aspects of your simulation can be varied."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Define Randomization Ranges"}),": Specify the min/max values or the set of choices for each parameter."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Integrate with Training Loop"}),": During each training iteration (or episode), randomly sample new values for these parameters. This ensures that the agent is constantly learning in a slightly different environment."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Train Robust Policy"}),": The agent learns a policy that is invariant to these randomized variations, making it robust to similar variations in the real world."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-randomizing-object-position-and-texture-in-isaac-sim-conceptual",children:"Example: Randomizing Object Position and Texture in Isaac Sim (Conceptual)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import omni.isaac.core.utils.carb as carb_utils\nfrom omni.isaac.kit import SimulationApp\nfrom omni.isaac.core import World\nfrom omni.isaac.core.objects import DynamicCuboid\nimport omni.replicator.core as rep\nimport numpy as np\n\n# Start Isaac Sim (headless for training)\nsimulation_app = SimulationApp({"headless": True})\n\nmy_world = World(stage_units_in_meters=1.0)\nmy_world.scene.add_default_ground_plane()\n\n# Add a cuboid to randomize\ncube = my_world.scene.add(\n    DynamicCuboid(\n        prim_path="/World/TargetCube",\n        position=np.array([0.0, 0.0, 0.5]),\n        size=0.1,\n    )\n)\n\n# Get some example textures (assuming these are defined in USD materials)\ntexture_paths = [\n    "/Looks/Material_01", # USD path to a material\n    "/Looks/Material_02",\n    "/Looks/Material_03",\n]\n\n# Set up replicator for randomization\nwith rep.trigger.on_frame():\n    # Randomize position of the cube\n    rep.modify.pose(cube, position=rep.distribution.uniform((-0.5, -0.5, 0.2), (0.5, 0.5, 0.8)))\n\n    # Randomize texture of the cube\n    rep.modify.attribute(cube.get_material_rel(), "material:binding", rep.distribution.choice(texture_paths))\n\n# The training loop would then interact with this randomized environment\nmy_world.reset()\nfor i in range(10000): # Run many training steps\n    my_world.step(render=True) # Advance physics and render\n    # Get observations, apply actions, calculate rewards...\n    # The environment parameters for the cube will be different each step due to randomization\n\nsimulation_app.close()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-domain-randomization",children:"When to use Domain Randomization?"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Perception Tasks"}),": Highly effective for training object detection, segmentation, and pose estimation models where visual variations are key."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reinforcement Learning"}),": When training policies in simulation to transfer to the real world."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sim2Real Transfer"}),": When the exact physical properties of the real world are unknown or difficult to model perfectly."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Domain Randomization, especially with powerful platforms like NVIDIA Isaac Sim/Replicator, provides a systematic and scalable way to create highly robust AI models that can successfully bridge the gap from simulation to the real world, a crucial step for deploying autonomous robots."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var t=i(6540);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);